# 规格说明书：车次列表页 (Module Specification: Train List Page)

## A. 模块史诗 (Module Epic)

为用户提供一个可根据其搜索条件动态筛选的、全面的火车车次与票务信息视图，帮助他们快速定位并选择最合适的出行方案。

## B. 原子用户故事 (Atomic User Stories) & TDD 验收标准

---

### **用户故事 1: 核心查询与车次展示 (Core Query and Train List Display)**

> 作为一名旅客，我想要输入出发地、目的地和出发日期后点击查询，以便看到所有匹配基础条件的可用车次列表。

| 验收维度 | 标准详情 (Given/When/Then) |
| :--- | :--- |
| **🔴 功能标准** | **场景 1: 成功查询**<br/>**Given**: 用户位于车次列表页，且查询表单为空。<br/>**When**: 用户在出发地输入框填入“北京”，目的地输入框填入“上海”，选择出发日期为“2025-11-20”，然后点击“查询”按钮。<br/>**Then**: 1. 前端应向后端 API (`/api/trains`) 发起一个 GET 请求，URL 参数为 `?from=北京&to=上海&date=2025-11-20`。 2. 在请求期间，车次信息展示区应显示一个加载中（Loading）的指示器。 3. 请求成功后，加载指示器消失，车次信息展示区被渲染出一个包含多个车次信息的列表。<br/><br/>**场景 2: 信息不完整查询**<br/>**Given**: 用户未填写出发地、目的地、出发日期中的至少一项。<br/>**When**: 用户点击“查询”按钮。<br/>**Then**: 1. 前端不应发送任何 API 请求。 2. 页面保持当前状态，不显示任何错误提示或车次列表。 |
| **🔵 技术与数据标准** | **数据结构 (TypeScript Interfaces)**:<br/>```typescript<br/>interface Train {<br/>  trainNo: string; // e.g., "G108"<br/>  fromStation: string;<br/>  toStation: string;<br/>  departureTime: string; // Format: "HH:mm"<br/>  arrivalTime: string; // Format: "HH:mm"<br/>  duration: string; // e.g., "4小时29分钟"<br/>  arrivalType: '当日到达' \| '次日到达';<br/>  seats: Seat[];<br/>}<br/><br/>interface Seat {<br/>  type: '一等座' \| '二等座' \| '软卧' \| '硬卧' \| '硬座' \| '无座';<br/>  status: '有' \| '候补' \| number \| '-';<br/>  price: number;<br/>}<br/>```<br/>**Data Seeding (SQLite 数据库播种)**:<br/>- **`stations` 表**: 必须预先填充至少 20 个中国主要城市站点（如北京、上海、广州）。每条记录需包含 `id`, `name` (e.g., "北京"), `pinyin` (e.g., "beijing"), 和 `initial` (e.g., "b") 字段，以支持后续的拼音首字母检索。<br/>- **`trains`, `schedules`, `seats` 表**: 必须包含至少 5 条完整的车次数据，其中必须有一条从“北京”到“上海”的线路，包含多种车次类型（G/D/Z）和席别，并有明确的沿途停靠站点、到发时间和价格信息，以确保查询功能可以被完整测试。 |
| **🎨 视觉与交互标准** | - 查询栏包含“出发地”、“目的地”、“出发日”三个核心输入控件和一个蓝色的“查询”按钮。<br/>- 点击“查询”后，在原车次列表的位置出现一个居中的加载动画（如旋转的菊花图）。<br/>- 查询结果以表格形式展示，表头为蓝色背景、白色字体，包含“车次”、“出发站/到达站”等列。 |
| **🛡️ 安全标准** | - **后端**: `/api/trains` 接口必须对所有传入的查询参数（`from`, `to`, `date`）进行严格的清理（Sanitization）和验证，以防御 SQL 注入攻击。必须使用参数化查询（Prepared Statements）。<br/>- **前端**: 所有用户输入在作为 URL 参数传递前，必须进行 URI 编码，防止参数注入和 XSS 攻击。 |

---

### **用户故事 2: 高级筛选与即时刷新 (Advanced Filtering and Instant Refresh)**

> 作为一名有特定偏好的旅客，我想要通过点选车次类型、出发车站、席别等筛选条件，让车次列表立即刷新，以便快速缩小选择范围。

| 验收维度 | 标准详情 (Given/When/Then) |
| :--- | :--- |
| **🔴 功能标准** | **Given**: 用户已经完成一次成功的查询，页面上正展示着一个车次列表。<br/>**When**: 用户在“车次类型”筛选区勾选了“D-动车”复选框。<br/>**Then**: 1. 车次列表应**立即**（无需再次点击“查询”按钮）进行刷新。 2. 刷新后的列表应只包含车次号以“D”开头的列车。 3. 此操作可以通过纯前端过滤实现，或向后端发送一个带有附加参数（如 `&trainType=D`）的新 API 请求。 |
| **🔵 技术与数据标准** | - **API 设计**: 后端 `/api/trains` 接口应支持可选的筛选参数，例如 `trainType`, `departureStation`, `seatType`, `departureTimeRange` 等。<br/>- **前端状态管理**: 所有筛选控件（复选框、下拉菜单）的当前状态必须由 React State (e.g., `useState`, `useReducer`) 管理。一个 `useEffect` Hook 应监听这些状态的变化，并在变化时触发数据重新过滤或重新获取的逻辑。 |
| **🎨 视觉与交互标准** | - 筛选条件（如“GC-高铁”、“D-动车”）以复选框（Checkbox）的形式存在。<br/>- 用户点击一个复选框后，该框应立即显示为“选中”状态。<br/>- 车次列表的更新过程应尽可能平滑，可以在列表区域短暂显示一个轻微的加载遮罩，以提示用户数据正在更新。 |
| **🛡️ 安全标准** | - **后端**: 所有接收到的筛选参数必须通过一个“允许列表”（Allow-list）进行校验。例如，`trainType` 参数只应接受 'GC', 'D', 'Z' 等预定义的值。任何不在列表中的值都应被忽略或触发一个错误响应，以防止恶意或无效的输入。 |

---

### **用户故事 3: 票务状态与价格可视化 (Ticket Status and Price Visualization)**

> 作为一名关心票量的旅客，我希望能直观地看到每趟车次不同席别的余票状态（如有票、票少、候补）和价格，以便我做出最佳的购票决策。

| 验收维度 | 标准详情 (Given/When/Then) |
| :--- | :--- |
| **🔴 功能标准** | **Given**: 车次列表已成功加载。其中一趟车次“G108”针对当前查询区间，二等座余票 > 20张，一等座余票 = 15张，硬卧余票 = 0张，且该车次本身不设软卧。<br/>**When**: 用户查看“G108”这一行的数据。<br/>**Then**: 在“G108”行内：<br/>- “二等座”列应显示绿色的“有”。<br/>- “一等座”列应显示黑色的“15”。<br/>- “硬卧”列应显示橙色的“候补”。<br/>- “软卧”列应显示灰色的“-”。 |
| **🔵 技术与数据标准** | - **后端逻辑**: 后端必须严格按照需求文档 3.4.2 节的规则实现余票计算逻辑。对于跨站查询，必须以“座位”为单位，检查该座位在查询区间内的每一段是否都处于“空闲”状态。<br/>- **API 响应**: API 返回的 `Seat` 对象中必须包含一个 `status` 字段，该字段的值由后端根据余票数量计算得出（`'有'`, `'候补'`, `具体数字`, `'-'`），供前端直接渲染。<br/>- **Data Seeding**: `bookings` 表中必须预置一些 booking 记录，以模拟部分路段被占用的场景，用于测试跨站查询的余票计算准确性。 |
| **🎨 视觉与交互标准** | - **颜色规范**: “有”为绿色；“候补”为橙色；具体数字为黑色；“-”为灰色。<br/>- **交互**: 每一行最右侧的“预定”按钮在有票或候补时应为可点击的蓝色按钮。 |
| **🛡️ 安全标准** | - **数据一致性**: 虽然不是典型的安全问题，但后端的余票计算和库存扣减必须是原子操作或在事务（Transaction）中执行，以防止在高并发场景下出现超卖（Race Condition）问题。 |

---

### **用户故事 4: 交互式站点选择 (Interactive Station Selection)**

> 作为一名用户，我希望在点击出发地或目的地输入框时，能弹出一个分类清晰的站点选择器，并支持模糊搜索，以便我能轻松快捷地找到并选择车站。

| 验收维度 | 标准详情 (Given/When/Then) |
| :--- | :--- |
| **🔴 功能标准** | **场景 1: 分类选择**<br/>**Given**: 用户位于车次列表页。<br/>**When**: 用户点击“出发地”输入框。<br/>**Then**: 1. 一个下拉菜单或浮层出现。 2. 浮层内包含“热门”、“ABCDE”、“FGHIJ”等标签页。 3. 点击“FGHIJ”标签，下方列表会更新为拼音首字母为 F, G, H, I, J 的所有车站。<br/><br/>**场景 2: 模糊搜索**<br/>**Given**: 站点选择浮层已打开。<br/>**When**: 用户在输入框中键入“sh”。<br/>**Then**: 浮层中的站点列表应实时更新，只显示名称或拼音中包含“sh”的站点（如“上海”、“石家庄”）。 |
| **🔵 技术与数据标准** | - **前端组件**: 需要创建一个独立的、可复用的 `StationSelector` React 组件。该组件在首次加载时通过 `/api/stations` 接口获取全量站点数据，并缓存在客户端以提高后续交互性能。<br/>- **API 设计**: 提供一个 `/api/stations` 接口，一次性返回所有可用车站的列表，每个车站对象包含 `id`, `name`, `pinyin`, `initial`。 |
| **🎨 视觉与交互标准** | - 站点选择器是一个位于输入框下方的浮层（z-index 较高），不会推开页面其他元素。<br/>- 标签页（Tabs）设计清晰，当前激活的标签页有明显的视觉区别（如下划线或不同背景色）。<br/>- 输入时，下方列表的过滤响应必须是实时的。 |
| **🛡️ 安全标准** | - **前端**: 用于过滤的搜索词在传递给任何正则表达式进行匹配前，需要进行转义，以防止 ReDoS (Regular Expression Denial of Service) 攻击。 |

## C. 独立测试边界 (Testing Boundaries)

为确保模块独立开发的顺利进行，以下是本模块的测试边界定义：

*   **本模块内闭环功能 (In-Scope / Closed-Loop)**:
    *   **UI 渲染**: 整个车次列表页面的所有静态和动态元素的渲染，包括所有筛选条件和车次信息。
    *   **状态管理**: 管理所有查询参数、筛选条件、模拟的用户登录状态以及从后端获取的车次数据的客户端状态。
    *   **API 交互**: 真实调用（在集成测试中）或模拟调用（在单元测试中）后端 `/api/trains` 和 `/api/stations` 接口，并正确处理加载中、成功、失败等不同响应状态。
    *   **客户端逻辑**: 实现所有页面内的动态逻辑，如即时筛选、表单校验（查询前必填项检查）、以及根据票务状态动态改变显示样式。

*   **Mock (模拟) 的功能边界**:
    *   **路由与导航**: **所有页面跳转均被 Mock**。
        *   点击顶部导航栏的“登录”、“注册”、“我的12306”等按钮，仅需断言（assert）一个模拟的 `navigationService` 或 `authService` 的相应函数被调用，**不执行实际页面跳转**。
        *   点击车次列表中的“预定”按钮，仅需断言一个模拟的 `bookingService.initiateBooking(trainDetails)` 函数被调用，并验证传入的 `trainDetails` 参数是否正确，**不跳转到订单填写页**。
    *   **用户认证**: 用户的登录状态（已登录/未登录）将通过 Mock 的 `AuthContext` 或组件 `props` 来模拟，以测试不同状态下的 UI 显示（例如，“您好，请登录” vs “您好，xx”）。**不涉及真实的登录 API 调用**。
    *   **后端 API (在前端单元测试中)**: 在使用 Vitest 和 React Testing Library 进行前端单元/组件测试时，所有对后端 API 的网络请求都将被拦截和模拟（例如使用 `msw` - Mock Service Worker）。这允许我们在没有真实后端运行的情况下，独立、可靠地测试前端的各种行为。